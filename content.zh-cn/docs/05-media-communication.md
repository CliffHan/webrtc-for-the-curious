---
title: 媒体通信
type: docs
weight: 6
---

# 我可以从WebRTC的媒体通信中得到什么？
WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。

WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。

WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。

## 它是如何工作的？
WebRTC使用[RFC 1889](https://tools.ietf.org/html/rfc1889)中定义的两个既有协议RTP和RTCP。

RTP是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。

RTCP是用于传达有关呼叫的元数据的协议。其格式非常灵活，因此您可以添加所需的任何内容。这用于传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应网络状况变化所必需的双向通信能力。

## 延迟与质量
实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。

### 现实世界的局限性
下面这些限制都是由现实世界的局限性引起的。这些都是您网络需要考虑的特性。

#### 带宽
带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。

当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。

#### 传输时间
传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。

#### 抖动
抖动是`传输时间`可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。

#### 数据包丢失
数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也并不算是罕见的情况！

#### 最大传输单位（MTU）
最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据打包为小数据包。

根据您采用的网络路径，MTU也将有所不同。您可以使用[Path MTU Discovery](https://tools.ietf.org/html/rfc1191)之类的协议来确定可以发送的最大数据包大小。

## Media 101（媒体格式基础知识）
### Codec（编解码器）
### Frame Types（帧类型）

## RTP
### Packet Format（包格式）
每个RTP数据包都具有以下结构：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

#### Version (V)
`Version`总是2。

#### Padding (P)
`Padding`是控制有效载荷是否具有填充值的布尔值。

有效负载的最后一个字节包含添加了多少填充字节的计数。

#### Extension (X)
如果设置的话，RTP报头将有扩展段（可选）。这点将在下面更详细地描述。

#### CSRC count (CC)
在`SSRC`之后，有效负载之前的`CSRC`标识符的数量。

#### Marker (M)
标记位没有预设含义，由用户决定。

在某些情况下，它是在用户讲话时设置的。它还通常用于标记关键帧。

#### Payload Type (PT)
`Payload Type`（负载类型）是此数据包所承载的编解码器的唯一标识符。

对于WebRTC，`Payload Type`是动态的。一个呼叫中的VP8可能与另一个呼叫中的不同。呼叫中的Offerer确定`Payload Type`到`Session Description`（会话描述符）中的编解码器的映射。

#### Sequence Number
`Sequence Number`（序列号）用于对流中的数据包进行排序。每次发送数据包时，`Sequence Number`都会增加1。

RTP被设计为可以在有损网络上使用。这为接收器提供了一种检测数据包何时丢失的方法。

#### Timestamp
此数据包的采样时刻。这不是全局时钟，而是在当前媒体流中所经过的时间。

#### Synchronization Source (SSRC)
`SSRC`是此流的唯一标识符。 这使您可以在单个流上传输多个媒体流。

#### Contributing Source (CSRC)
一个列表，用于表示哪些`SSRC`参与到了这个数据包中。

这通常用于语音指示器。假设在服务器端，您将多个音频源组合到一个单独的RTP流中。然后，您可以在此字段中表示`输入流A和C此时正在讲话`。

### Extensions（扩展）

### Mapping Payload Types to Codecs（将负载类型映射到编解码器）

## RTCP

### Packet Format
每个RTCP数据包都具有以下结构：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |       PT      |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

#### Version (V)
`Version`总是2。

#### Padding (P)
`Padding`是控制有效载荷是否具有填充值的布尔值。

有效负载的最后一个字节包含添加了多少填充字节的计数。

#### Reception Report Count (RC)
此数据包中的报告数。单个RTCP数据包可以包含多个事件。

#### Packet Type (PT)
指示RTCP数据包类型的唯一标识符。WebRTC代理不需要支持所有这些类型，并且代理之间的支持能力可以是不同的。下面这些是您可能经常看到的类型。

* 完整的帧内请求（FIR）-`192`
* 否定确认（NACK）-`193`
* 发送方报告-`200`
* 接收方报告-`201`
* 通用RTP反馈-`205`

这些分组类型的意义将在下面更详细地描述。

### Full INTRA-frame Request（完整的帧内请求）
此RTCP消息通知发送者它需要发送完整图像。这适用于编码器为您提供了帧的一部分，但您无法对其进行解码的情况。

之所以会发生这种情况，是因为您有很多数据包丢失，或者解码器崩溃了。

### Negative ACKnowledgements（否定确认）
NACK请求发送方重新发送单个RTP数据包。这通常是由于RTP数据包丢失而引起的，但是也可能由于延迟而发生。

与请求重新发送整个帧相比，NACK的带宽效率要高得多。由于RTP将数据包分解成很小的块，因此您实际上只是在请求丢失的一个很小的部分。

### Sender/Receiver Reports（发送方/接收方报告）
这些报告用于在代理之间发送统计信息。它传达了实际接收到的和抖动的数据包数量。

这些报告可用于常规、诊断或者基本的拥塞控制。

### Generic RTP Feedback（通用RTP反馈）

## How RTP/RTCP solve problems
RTP and RTCP then work together to solve all the problems caused by networks. These techniques are still constantly changing!

## RTP/RTCP是如何解决问题的
RTP和RTCP需要协同解决网络引起的所有问题。这些技术仍在不断进化中！

### 否定确认
也称为NACK。这是使用RTP处理数据包丢失的一种方法。

NACK是发送回发送方以请求重发的RTCP消息。接收方使用SSRC和序列号制作RTCP消息。 如果发送方没有可用于重新发送的RTP数据包，则忽略该消息。

### Forward Error Correction（前向纠错）
简称为FEC。处理丢包的另一种方法。FEC指的是发送方多次重复发送相同的数据，甚至是在接收方没有要求的情况下发送。这可以在RTP级别完成，甚至可以在编解码器以下的层级完成。

在呼叫的数据丢包率比较稳定的情况下，FEC比NACK好得多。对于NACK，必须先请求然后重新传输数据包，这样的数据往返对性能影响很大。

### Congestion Control（拥塞控制）
拥塞控制是根据网络属性调整媒体的行为。如果带宽较小，则需要发送质量较低的视频。

拥塞控制就是要权衡取舍。

### JitterBuffer（抖动缓冲）
